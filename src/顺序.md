我们已经掌握了 prosemirror-model 中两个最核心的概念：

1.  `schema.ts`: 定义文档**规则**的蓝图 (`Schema`, `NodeType`, `MarkType`)。
2.  `node.ts`: 代表文档**实体**的数据结构 (`Node`)。

现在，我们已经打下了坚实的基础。为了继续构建我们的知识体系，我建议按照以下逻辑顺序进行：

1.  **`fragment.ts`**: 这是最直接的下一步。我们已经知道每个 `Node` 实例都有一个 `content` 属性，它的类型是 `Fragment`。`Fragment` 是一个非常重要的辅助类，它代表一个有序的节点序列（即一个节点的子节点列表）。它被设计成与 `Node` 类似的不可变数据结构，并提供了许多高效操作子节点序列的方法。不理解 `Fragment`，我们对 `Node` 的 `content` 的理解就是不完整的。

2.  **`mark.ts`**: 在理解了 `NodeType` 和 `Node` 之后，我们应该回过头来完成对标记（Marking）的理解。这个文件定义了 `Mark` 类（`MarkType` 的实例）和 `MarkSet`。这会让我们明白标记是如何被创建、存储（在一个不可变的集合中）并附加到节点上的。

3.  **`resolvedpos.ts`**: 我们已经了解了 `nodeSize` 和基于整数的位置索引系统。但是一个单纯的数字（比如 `12`）并没有太多上下文。`ResolvedPos` 就是将这个数字位置“解析”成一个包含丰富上下文信息对象（比如它在哪一层级的哪个父节点中、它前后的节点是什么、当前位置可用的标记是什么等等）。这是进行任何复杂文档分析和操作的基础。

4.  **`replace.ts`**: 这是模型包中最核心、也是最复杂的算法所在。它包含了 `Slice` 类（用于表示文档的“切片”，是复制/粘贴的基础）和 `replace` 函数的实现。ProseMirror 中**所有**的文档变更操作，无论多么复杂，最终都会归结为对 `replace` 的调用。理解了这个文件，你就能理解 ProseMirror 文档是如何以一种符合 Schema 规则的方式进行原子化更新的。
