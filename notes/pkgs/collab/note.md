正在收集工作区信息好的，我们来深入讲解 prosemirror-collab 模块。

prosemirror-collab 是一个 ProseMirror 插件，它为编辑器实现协同编辑功能提供了一个健壮的框架。它本身不处理网络通信，而是提供了一套机制来管理本地和远程的变更，使得将 ProseMirror 集成到任何协同编辑后端成为可能。

### 1. 核心思想：中央集权与乐观更新

ProseMirror 的协同模型基于一个**中央集权**的架构。这意味着有一个权威的中央服务（通常是你的服务器）负责接收所有客户端的变更，并确定它们最终的、唯一的顺序。

客户端则采用**乐观更新**的策略：用户的操作会立即在本地编辑器上生效，而不需要等待服务器的确认。当来自其他协作者的变更到达时，prosemirror-collab 模块负责将本地尚未被服务器确认的变更，在远程变更的基础上进行“变基”（Rebase），从而使所有客户端最终收敛到一致的状态。

### 2. 核心概念与 API

- **`collab(config)`**: 这是模块的主要入口，一个插件工厂函数。你需要将它添加到编辑器的插件列表中。它接收 `version` 和 `clientID` 作为配置。

  - `version`: 文档的初始版本号。
  - `clientID`: 当前客户端的唯一标识符。

- **`CollabState`**: 这是协同插件所管理的状态，包含两个关键部分：

  - `version`: 当前客户端已从中央权威处同步到的最新版本号。
  - `unconfirmed`: 一个 `Rebaseable` 对象的数组，代表了本地已应用但尚未被中央权威确认的变更步骤（`Step`）。

- **`sendableSteps(state)`**: 当你需要将本地变更发送到服务器时，调用此函数。它会返回一个包含 `version`、`steps` 和 `clientID` 的对象。如果返回 `null`，则表示没有需要发送的变更。你的应用代码负责将这个对象通过网络发送到中央服务器。

- **[`receiveTransaction(state, steps, clientIDs)`](prosemirror-collab/src/collab.ts)**: 当你的应用从服务器接收到一批新的变更时，调用此函数。它会返回一个新的 `Transaction`，你需要将这个事务应用到编辑器状态上。
  - `steps`: 从服务器接收到的 `Step` 数组。
  - `clientIDs`: 与 `steps` 数组一一对应的、产生这些步骤的客户端 ID 数组。

### 3. 工作流程与“变基”魔法

协同编辑的完整流程如下：

1.  **本地编辑**: 用户在编辑器中进行操作。ProseMirror 生成一个事务（`Transaction`），其中包含相应的 `Step`。`collab` 插件会将这些 `Step` 包装成 `Rebaseable` 对象，存入 `unconfirmed` 列表中。

2.  **发送变更**: 你的应用代码定期（或在每次编辑后）调用 `sendableSteps`，获取未确认的步骤，并将它们连同当前文档版本号发送到服务器。

3.  **服务器处理**: 服务器接收到客户端的变更。它会检查客户端提交的 `version` 是否与服务器上当前的最新版本匹配。

    - 如果匹配，服务器接受这些 `Step`，将它们应用到中央文档上，增加版本号，然后将这些 `Step` 广播给所有其他连接的客户端。
    - 如果不匹配，说明客户端的文档版本落后了，服务器会拒绝此次提交。

4.  **接收变更**: 客户端从服务器接收到一批广播来的 `Step`。此时，它调用 `receiveTransaction`。

5.  **变基 (Rebasing)**: 这是最关键的一步，在 `receiveTransaction` 内部发生。
    - 插件首先检查收到的 `steps` 中，哪些是自己之前发送并被服务器确认的。这些步骤会被从本地的 `unconfirmed` 列表中移除。
    - 剩下的 `steps` 是来自其他协作者的。
    - 此时，本地可能还有一些 `unconfirmed` 的步骤（例如，在发送和接收的间隙中，用户又进行了新的编辑）。
    - 插件会使用 `rebaseSteps` 函数执行变基操作：它会暂时**撤销**本地未确认的步骤，然后**应用**所有来自远程的步骤，最后再**重新应用**本地的步骤。在重新应用时，这些本地步骤会通过 prosemirror-transform 的 `map` 方法进行坐标变换，以适应远程变更所带来的文档结构变化。

这个过程确保了即使用户正在输入，远程的变更也能被平滑地插入，而用户的输入（未确认的变更）则会被智能地调整到正确的新位置上，最终所有客户端的文档内容都会收敛一致。

prosemirror-collab 与 `prosemirror-history` 也能很好地协同工作，确保在协同编辑环境下的撤销/重做行为符合预期。
